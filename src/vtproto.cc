#include "vtproto.h"
namespace tact {
namespace vtproto {

namespace encode {

bool callbackEncodeString(pb_ostream_t* stream, const pb_field_iter_t* field,
                          void* const* arg) {
  // Serial.println("Encoding String!!!");
  const char* str = (const char*)(*arg);
  // https://stackoverflow.com/a/57569764
  if (!pb_encode_tag_for_field(stream, field)) return false;
  // Serial.println(strlen(str));
  // Serial.println((char *)str);
  return pb_encode_string(stream, (uint8_t*)str, strlen(str));
  // pb_encode_string(stream, (const char *)arg, strlen((const char *)arg));
}
FileHeader getHeader(uint32_t format_version, char* pattern_name, char* author,
                     uint32_t duration_ms, uint32_t n_instructions,
                     uint32_t n_channels) {
  FileHeader f = FileHeader_init_default;
  f.format_version = format_version;
  f.duration_ms = duration_ms;
  f.n_instructions = n_instructions;
  f.n_channels = n_channels;

  // Add callbacks to function
  f.pattern_name.funcs.encode = callbackEncodeString;
  f.pattern_name.arg = pattern_name;

  f.author.funcs.encode = callbackEncodeString;
  f.author.arg = author;

  return f;
}
/**
 * \brief Function for encoding a uint32_t array (specifically for
 * InstAddToGroup)(https://jpa.kapsi.fi/nanopb/docs/reference.html#pb_callback_t)
 *
 * \param *stream pointer to nanopb output stream
 * \param *field pointer to descritpion (autogenerated by generated field
 * nanopb, see vtproto.pb.h ) \param *arg argument pointer (see link for more
 * information)
 *
 * \return true on success, false on error
 * **/
bool callbackIdsToAddToGroup(pb_ostream_t* stream, const pb_field_iter_t* field,
                             void* const* arg) {
  Set* ids = (Set*)(*arg);
  /* First calculate the message size using a non-writing substream. */
  pb_ostream_t substream = PB_OSTREAM_SIZING;
  size_t size;
  for (uint8_t i = 1; i <= ids->count(); i++) {
    if (!pb_encode_varint(&substream, ids->getNth(i))) {
#ifdef DEBUG_TACTILE
#ifndef UNIT_TEST
      const char* error = PB_GET_ERROR(stream);
      // Serial.printf("output id encoding error: %s\n", error);
      Serial.print("output id encoding error: ");
      Serial.println(error);
#endif  // UNIT_TEST
#endif  // DEBUG_TACTILE
      return false;
    }
  }

  size = substream.bytes_written;
#ifdef DEBUG_TACTILE
#ifndef UNIT_TEST
  // Serial.printf("substream bytes written: %i\n", size);
  Serial.print("substream bytes written: ");
  Serial.println(size);
  // First elements contains length of the passed array
  // Serial.printf("encoding ids for field tag: %i\n", field->tag);
  Serial.print("encoding ids for field tag: ");
  Serial.println(field->tag);
#endif  // UNIT_TEST
#endif  // DEBUG_TACTILE

  if (!pb_encode_tag(stream, PB_WT_STRING, field->tag)) {
#ifdef DEBUG_TACTILE
#ifndef UNIT_TEST
    const char* error = PB_GET_ERROR(stream);
    // Serial.printf("output id encoding error: %s\n", error);
    Serial.print("output id encoding error: ");
    Serial.println(error);
#endif  // UNIT_TEST
#endif  // DEBUG_TACTILE
    return false;
  }
  if (!pb_encode_varint(stream, size)) {
#ifdef DEBUG_TACTILE
#ifndef UNIT_TEST
    const char* error = PB_GET_ERROR(stream);
    // Serial.printf("output id encoding error: %s\n", error);
    Serial.print("output id encoding error: ");
    Serial.println(error);
#endif  // UNIT_TEST
#endif  // DEBUG_TACTILE
    return false;
  }
  for (uint8_t i = 1; i <= ids->count(); i++) {
    if (!pb_encode_varint(stream, ids->getNth(i))) {
#ifdef DEBUG_TACTILE
#ifndef UNIT_TEST
      const char* error = PB_GET_ERROR(stream);
      // Serial.printf("output id encoding error: %s\n", error);
      Serial.print("output id encoding error: ");
      Serial.println(error);
#endif  // UNIT_TEST
#endif  // DEBUG_TACTILE
      return false;
    }
  }
  return true;
}

InstInstantlySetParameter _getInstInstantlySetParameterHeader(
    uint8_t which_target_id, uint8_t target_id, uint8_t which_parameter) {
  InstInstantlySetParameter i;
  which_target_id == InstInstantlySetParameter_group_id_tag
      ? i.which_target_id = InstInstantlySetParameter_group_id_tag
      : i.which_target_id = InstInstantlySetParameter_channel_id_tag;
  which_target_id == InstInstantlySetParameter_group_id_tag
      ? i.target_id.group_id = target_id
      : i.target_id.channel_id = target_id;
  which_parameter == InstInstantlySetParameter_frequency_hz_tag
      ? i.which_parameter = InstInstantlySetParameter_frequency_hz_tag
      : i.which_parameter = InstInstantlySetParameter_intensity_tag;
  return i;
}

InstInstantlySetParameter getInstInstantlySetFrequency(uint8_t which_target_id,
                                                       uint8_t target_id,
                                                       uint32_t frequency_hz) {
  InstInstantlySetParameter i = _getInstInstantlySetParameterHeader(
      which_target_id, target_id, InstInstantlySetParameter_frequency_hz_tag);
  i.parameter.frequency_hz = frequency_hz;
  return i;
}

InstInstantlySetParameter getInstInstantlySetIntensity(uint8_t which_target_id,
                                                       uint8_t target_id,
                                                       float intensity) {
  InstInstantlySetParameter i = _getInstInstantlySetParameterHeader(
      which_target_id, target_id, InstInstantlySetParameter_intensity_tag);

  if (intensity > 1.0)
    intensity = 1.0;
  else if (intensity < 0)
    intensity = 0;

  i.parameter.intensity = intensity;
  return i;
}

InstAddToGroup getInstAddToGroup(uint32_t group_id, Set& ids) {
  InstAddToGroup a = InstAddToGroup_init_zero;
  a.group_id = group_id;
  a.ids_to_be_added.funcs.encode = encode::callbackIdsToAddToGroup;
  a.ids_to_be_added.arg = &ids;
  return a;
}

InstInterpolateParameter _getInstInterpolateHeader(uint8_t which_target_id,
                                                   uint8_t target_id,
                                                   uint8_t which_parameter) {
  InstInterpolateParameter i;
  which_target_id == InstInterpolateParameter_group_id_tag
      ? i.which_target_id = InstInterpolateParameter_group_id_tag
      : i.which_target_id = InstInterpolateParameter_channel_id_tag;
  which_target_id == InstInterpolateParameter_group_id_tag
      ? i.target_id.group_id = target_id
      : i.target_id.channel_id = target_id;
  which_parameter == InstInterpolateParameter_frequency_hz_tag
      ? i.which_parameter = InstInterpolateParameter_frequency_hz_tag
      : i.which_parameter = InstInterpolateParameter_intensity_tag;
  return i;
}
InstInterpolateParameter getInstInterpolateIntenisty(uint8_t which_target_id,
                                                     uint8_t target_id,
                                                     float intensity,
                                                     uint32_t ms) {
  InstInterpolateParameter i = _getInstInterpolateHeader(
      which_target_id, target_id, InstInterpolateParameter_intensity_tag);
  i.parameter.intensity = intensity;
  i.duration_ms = ms;
  return i;
}
InstInterpolateParameter getInstInterpolateFrequency(uint8_t which_target_id,
                                                     uint8_t target_id,
                                                     uint32_t frequency_hz,
                                                     uint32_t ms) {
  InstInterpolateParameter i = _getInstInterpolateHeader(
      which_target_id, target_id, InstInterpolateParameter_frequency_hz_tag);
  i.parameter.frequency_hz = frequency_hz;
  i.duration_ms = ms;
  return i;
}
InstWait getInstWait(uint32_t ms) { return InstWait{ms}; }
}  // namespace encode

namespace decode {
bool callbackDecodeString(pb_istream_t* stream, const pb_field_t* field,
                          void** arg) {
  // https://github.com/nanopb/nanopb/blob/a9b7a2f91ba7dad78179500af1a0c241bad0b099/tests/callbacks/decode_callbacks.c#L10
  // TODO Check this flaky stuff out

  uint8_t* str = (uint8_t*)(*arg);
  uint8_t write_len = stream->bytes_left;
  // Check if max buffer length is big enough to store decoded message. Max
  // buffer length is stored at str[0]
  if (stream->bytes_left > (*str - 3)) {
    // Serial.println("Too small, truncating to available size");
    write_len = *str - 3;
    // Serial.println("Too small");
    // return false;
  }

  // Serial.println("DECODING");
  // Serial.printf("Writing %i of %i bytes\n", write_len, stream->bytes_left);

  // Store length of message in str[1]
  ++str;
  *str = write_len;

  // write message starting at str[2]
  ++str;
  // if (!pb_read(stream, str, stream->bytes_left))
  if (!pb_read(stream, str, write_len)) return false;

  // empty out stream
  if (stream->bytes_left > 0) {
    {
      if (!pb_read(stream, NULL, stream->bytes_left)) return false;
    }
  }

  // Serial.println(stream->bytes_left);
  // return stream->bytes_left == 0;
  return true;
}

// First element of char array has to contain the length of the array, second
// element will contain length of the string itself which starts at the second
// elements
FileHeader getHeader(char* pattern_name_buf, char* author_buf) {
  FileHeader f = FileHeader_init_default;

  if (pattern_name_buf != nullptr) {
    f.pattern_name.funcs.decode = callbackDecodeString;
    f.pattern_name.arg = pattern_name_buf;

    for (size_t i = 1; i < pattern_name_buf[0]; i++) {
      pattern_name_buf[i] = 0;
    }
  }
  if (author_buf != nullptr) {
    f.author.funcs.decode = callbackDecodeString;
    f.author.arg = author_buf;

    for (size_t i = 1; i < author_buf[0]; i++) {
      author_buf[i] = 0;
    }
  }

  return f;
}

bool callbackAddIdToGroup(pb_istream_t* stream, const pb_field_iter_t* field,
                          void** arg) {
  if (stream->bytes_left == 0) return false;

  uint64_t value;
  if (!pb_decode_varint(stream, &value)) {
#ifndef UNIT_TEST
#ifdef DEBUG_TACTILE
    const char* error = PB_GET_ERROR(stream);
    Serial.print("decode error: ");
    Serial.println(error);
#endif
#endif
    return false;
  }

  // uint32_t *ids = *(uint32_t *)*arg;
  Set* ids = (Set*)*arg;
  ids->add(value);
#ifdef DEBUG_TACTILE
#ifndef UNIT_TEST
  // Serial.printf("decoded number %lld\n", value);
  Serial.print("decoded number ");
  Serial.println(value);
#endif
#endif
  return true;
}
bool callbackInstruction(pb_istream_t* stream, const pb_field_iter_t* field,
                         void** arg) {
  if (field->tag == Instruction_add_channels_to_group_tag) {
    InstAddToGroup* f = (InstAddToGroup*)field->pData;
    f->ids_to_be_added.funcs.decode =
        tact::vtproto::decode::callbackAddIdToGroup;
    tact::vtproto::Group* g = (tact::vtproto::Group*)(*arg);
    f->ids_to_be_added.arg = &g->channels_;
  } else if (field->tag == Instruction_add_groups_to_group_tag) {
    InstAddToGroup* f = (InstAddToGroup*)field->pData;
    f->ids_to_be_added.funcs.decode =
        tact::vtproto::decode::callbackAddIdToGroup;
    tact::vtproto::Group* g = (tact::vtproto::Group*)(*arg);
    f->ids_to_be_added.arg = &g->groups_;
  }
  /* Once we return true, pb_dec_submessage() will go on to decode the
   * submessage contents. But if we want, we can also decode it ourselves
   * above and leave stream->bytes_left at 0 value, inhibiting automatic
   * decoding.
   */
  return true;
}

Instruction getInstruction(Group& group) {
  Instruction a = Instruction_init_default;
  a.cb_concrete_instruction.funcs.decode =
      tact::vtproto::decode::callbackInstruction;
  a.cb_concrete_instruction.arg = &group;
  return a;
}

InstAddToGroup getInstAddChannelsToGroup(Group& group) {
  InstAddToGroup dec = InstAddToGroup_init_zero;
  dec.ids_to_be_added.funcs.decode = callbackAddIdToGroup;
  dec.ids_to_be_added.arg = &group.channels_;
  return dec;
}
InstAddToGroup getInstAddGroupsToGroup(Group& group) {
  InstAddToGroup dec = InstAddToGroup_init_zero;
  dec.ids_to_be_added.funcs.decode = callbackAddIdToGroup;
  dec.ids_to_be_added.arg = &group.groups_;
  return dec;
}
}  // namespace decode
}  // namespace vtproto

}  // namespace tact